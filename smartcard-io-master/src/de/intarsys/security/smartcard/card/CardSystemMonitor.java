/*
 * Copyright (c) 2013, intarsys consulting GmbH
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of intarsys nor the names of its contributors may be used
 *   to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package de.intarsys.security.smartcard.card;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

import de.intarsys.tools.attribute.Attribute;
import de.intarsys.tools.concurrent.ThreadTools;
import de.intarsys.tools.event.AttributeChangedEvent;
import de.intarsys.tools.event.Event;
import de.intarsys.tools.event.INotificationListener;
import de.intarsys.tools.message.MessageBundle;
import de.intarsys.tools.string.StringTools;

/**
 * Monitors a {@link ICardSystem}'s {@link ICardTerminal} and {@link ICard}
 * instances and dispatches all events to an {@link ICardSystemListener}.
 * 
 * Dispatching is using a single, dedicated thread to ensure event ordering.
 */
public class CardSystemMonitor {

	/**
	 * A callback interface for events generated by the
	 * {@link CardSystemMonitor}.
	 * 
	 */
	public interface ICardSystemListener {

		/**
		 * The {@link ICard#getState()} has changed.
		 * 
		 * @param card
		 */
		public void onCardChanged(ICard card);

		/**
		 * A new {@link ICard} is available in an {@link ICardTerminal}.
		 * 
		 * @param card
		 */
		public void onCardInserted(ICard card);

		/**
		 * An {@link ICard} is removed from an {@link ICardTerminal}.
		 * 
		 * @param card
		 */
		public void onCardRemoved(ICard card);

		/**
		 * A new {@link ICardTerminal} is connected to the system.
		 * 
		 * @param terminal
		 */
		public void onCardTerminalConnected(ICardTerminal terminal);

		/**
		 * An {@link ICardTerminal} is disconnected from the system.
		 * 
		 * @param terminal
		 */
		public void onCardTerminalDisconnected(ICardTerminal terminal);

	}

	private static int COUNTER = 0;

	private static final Logger Log = PACKAGE.Log;

	private static final MessageBundle Msg = PACKAGE.Messages;

	private static final ExecutorService eventExecutor = Executors
			.newSingleThreadExecutor(ThreadTools
					.newThreadFactoryDaemon("CardSystemMonitor Executor Thread")); //$NON-NLS-1$

	final private ICardSystem cardSystem;

	final private List<ICardTerminal> cardTerminals;

	final private int id = COUNTER++;

	final private List<ICardSystemListener> listeners = new ArrayList<>();

	private final INotificationListener listenCardEvents = new INotificationListener() {
		@Override
		public void handleEvent(Event event) {
			final CardEvent cardEvent = (CardEvent) event;
			synchronized (lock) {
				// we lock to ensure correct event sequence
				if (!started) {
					return;
				}
				getEventExecutor().submit(new Runnable() {
					@Override
					public void run() {
						onCardUpdate(cardEvent.getCard(),
								cardEvent.getNewState());
					}
				});
			}
		}
	};

	private final INotificationListener listenCardSystemChanged = new INotificationListener() {
		@Override
		public void handleEvent(Event event) {
			final AttributeChangedEvent ace = (AttributeChangedEvent) event;
			synchronized (lock) {
				// we lock to ensure correct event sequence
				if (!started) {
					return;
				}
				getEventExecutor().submit(new Runnable() {
					@Override
					public void run() {
						Object value = ace.getOldValue();
						if (value instanceof ICardTerminal) {
							onCardTerminalDisconnect((ICardTerminal) value);
						}
						value = ace.getNewValue();
						if (value instanceof ICardTerminal) {
							onCardTerminalConnect((ICardTerminal) value);
						}
					}
				});
			}
		}
	};

	protected final Object lock = new Object();

	private boolean started = false;

	final private Attribute attrSeen = new Attribute("seen");

	public CardSystemMonitor(ICardSystem cardSystem) {
		this.cardSystem = cardSystem;
		cardTerminals = new ArrayList<ICardTerminal>();
	}

	public void addCardSystemListener(ICardSystemListener listener) {
		synchronized (listeners) {
			listeners.add(listener);
		}
	}

	protected String getCardConnectedMessage() {
		return Msg.getString("CardSystemMonitor.stateConnected"); //$NON-NLS-1$
	}

	protected String getCardConnectingMessage() {
		return Msg.getString("CardSystemMonitor.stateConnecting"); //$NON-NLS-1$
	}

	protected String getCardConnectionFailedMessage(CardException cardException) {
		String msg = cardException.getLocalizedMessage();
		if (msg == null || "null".equals(msg)) { //$NON-NLS-1$
			return Msg
					.getString("CardSystemMonitor.stateConnectedFailedUnspecified"); //$NON-NLS-1$
		} else {
			return Msg.getString("CardSystemMonitor.stateConnectedFailed", //$NON-NLS-1$
					msg);
		}
	}

	protected String getCardStateMessage(ICard card) {
		if (card == null) {
			return Msg.getString("CardSystemMonitor.stateNoCardAvailable"); //$NON-NLS-1$
		}
		EnumCardState state = card.getState();
		if (state.isInvalid()) {
			return Msg.getString("CardSystemMonitor.stateNoCardAvailable"); //$NON-NLS-1$
		} else if (state.isConnectedExclusive()) {
			return Msg.getString("CardSystemMonitor.stateConnectedExclusive"); //$NON-NLS-1$
		} else if (state.isConnectedShared() || state.isNotConnected()) {
			return Msg.getString("CardSystemMonitor.stateNotConnected"); //$NON-NLS-1$
		}
		return StringTools.EMPTY;
	}

	protected List<ICardTerminal> getCardTerminals() {
		synchronized (lock) {
			return new ArrayList<ICardTerminal>(cardTerminals);
		}
	}

	protected String getCardUnsupportedMessage() {
		return Msg.getString("CardSystemMonitor.unsupportedCard"); //$NON-NLS-1$
	}

	protected ExecutorService getEventExecutor() {
		return eventExecutor;
	}

	protected boolean getSeen(ICard card) {
		/*
		 * there's no concurrent access to getSeen.
		 */
		Object seen = card.getAttribute(attrSeen);
		if (seen == null) {
			card.setAttribute(attrSeen, Boolean.TRUE);
			return false;
		}
		return true;
	}

	public boolean isCardAvailable() {
		synchronized (lock) {
			for (ICardTerminal terminal : cardTerminals) {
				if (terminal.getCard() != null) {
					return true;
				}
			}
			return false;
		}
	}

	public boolean isCardTerminalAvailable() {
		synchronized (lock) {
			return cardTerminals.size() > 0;
		}
	}

	public boolean isStarted() {
		synchronized (lock) {
			return started;
		}
	}

	protected void onCardChanged(ICard card) {
		if (Log.isLoggable(Level.FINEST)) {
			Log.finest("" + this + " " + card + " changed"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		}
		List<ICardSystemListener> tempListeners;
		synchronized (listeners) {
			tempListeners = new ArrayList<>(listeners);
		}
		for (ICardSystemListener listener : tempListeners) {
			listener.onCardChanged(card);
		}
	}

	protected void onCardInserted(ICard card) {
		Log.info("" + this + " " + card + " inserted"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		List<ICardSystemListener> tempListeners;
		synchronized (listeners) {
			tempListeners = new ArrayList<>(listeners);
		}
		for (ICardSystemListener listener : tempListeners) {
			listener.onCardInserted(card);
		}
	}

	protected void onCardRemoved(ICard card) {
		Log.info("" + this + " " + card + " removed"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		List<ICardSystemListener> tempListeners;
		synchronized (listeners) {
			tempListeners = new ArrayList<>(listeners);
		}
		for (ICardSystemListener listener : tempListeners) {
			listener.onCardRemoved(card);
		}
	}

	protected void onCardTerminalConnect(ICardTerminal cardTerminal) {
		synchronized (lock) {
			if (!started) {
				return;
			}
			if (cardTerminals.contains(cardTerminal)) {
				return;
			}
			cardTerminals.add(cardTerminal);
		}
		List<ICardSystemListener> tempListeners;
		synchronized (listeners) {
			tempListeners = new ArrayList<>(listeners);
		}
		for (ICardSystemListener listener : tempListeners) {
			listener.onCardTerminalConnected(cardTerminal);
		}
		onCardTerminalConnected(cardTerminal);
	}

	/**
	 * This method is always running in the executor context. This is the reason
	 * why it is not necessary to synchronize when adding the listener and call
	 * "onCardUpdate" - external card updates are always enqueued.
	 * 
	 * @param terminal
	 */
	protected void onCardTerminalConnected(ICardTerminal terminal) {
		Log.info("" + this + " " + terminal + " connected"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		terminal.addNotificationListener(CardEvent.ID, listenCardEvents);
		ICard card = terminal.getCard();
		if (card != null) {
			onCardUpdate(card, card.getState());
		}
	}

	protected void onCardTerminalDisconnect(ICardTerminal cardTerminal) {
		synchronized (lock) {
			if (!started) {
				return;
			}
			if (!cardTerminals.remove(cardTerminal)) {
				if (Log.isLoggable(Level.FINE)) {
					Log.fine("" + this + " " + cardTerminal + " not registered"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
				}
				return;
			}
		}
		List<ICardSystemListener> tempListeners;
		synchronized (listeners) {
			tempListeners = new ArrayList<>(listeners);
		}
		for (ICardSystemListener listener : tempListeners) {
			listener.onCardTerminalDisconnected(cardTerminal);
		}
		onCardTerminalDisconnected(cardTerminal);
	}

	/**
	 * This method is always running in the executor context. This is the reason
	 * why it is not necessary to synchronize when adding the listener and call
	 * "onCardUpdate" - external card updates are always enqueued.
	 * 
	 * When "disconnected" is called back, the terminal is already disposed, the
	 * respective card state change callback is already performed.
	 * 
	 * @param terminal
	 */
	protected void onCardTerminalDisconnected(final ICardTerminal terminal) {
		Log.info("" + this + " " + terminal + " disconnected"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		terminal.removeNotificationListener(CardEvent.ID, listenCardEvents);
	}

	protected void onCardUpdate(ICard card, EnumCardState state) {
		synchronized (lock) {
			if (!started) {
				return;
			}
		}
		if (state.isInvalid()) {
			onCardRemoved(card);
		} else {
			if (getSeen(card)) {
				onCardChanged(card);
			} else {
				onCardInserted(card);
			}
		}
	}

	public void removeCardSystemListener(ICardSystemListener listener) {
		synchronized (listeners) {
			listeners.remove(listener);
		}
	}

	public void start() {
		synchronized (lock) {
			if (started) {
				return;
			}
			started = true;
			Log.info("" + this + " start"); //$NON-NLS-1$ //$NON-NLS-2$
			cardTerminals.clear();
			cardSystem.addNotificationListener(AttributeChangedEvent.ID,
					listenCardSystemChanged);
			ICardTerminal[] tempTerminals = cardSystem.getCardTerminals();
			for (final ICardTerminal cardTerminal : tempTerminals) {
				getEventExecutor().submit(new Runnable() {
					@Override
					public void run() {
						onCardTerminalConnect(cardTerminal);
					}
				});
			}
		}
	}

	public void stop() {
		List<ICardTerminal> tempTerminals;
		synchronized (lock) {
			if (!started) {
				return;
			}
			started = false;
			Log.info("" + this + " stop"); //$NON-NLS-1$ //$NON-NLS-2$
			cardSystem.removeNotificationListener(AttributeChangedEvent.ID,
					listenCardSystemChanged);
			tempTerminals = new ArrayList<ICardTerminal>(cardTerminals);
			for (ICardTerminal cardTerminal : tempTerminals) {
				cardTerminal.removeNotificationListener(CardEvent.ID,
						listenCardEvents);
			}
			cardTerminals.clear();
		}
	}

	@Override
	public String toString() {
		return getClass().getName() + " " + id; //$NON-NLS-1$
	}
}
